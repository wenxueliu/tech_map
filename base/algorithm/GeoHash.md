

经纬度地图：纵线是经度（-180 \~180）横线为纬度（-90~90）



GeoHash是一种地址编码方法。他能够把二维的空间经纬度数据编码成一个二进制字符串，然后base32后成为一个短字符串。以(`123.15488794512`, `39.6584212421`)为例计算geohash：

1、第一步，经纬度分别计算出一个二进制数，通过二分法不断查找最小区间。

以经度`123.15488794512`为例，计算过程如下：

| 精度 | 左边界   | 平均值   | 右边界   | 结果 |
| ---- | -------- | -------- | -------- | ---- |
| 1    | -180     | 0        | 180      | 1    |
| 2    | 0        | 90       | 180      | 1    |
| 3    | 90       | 135      | 180      | 0    |
| 4    | 90       | 112.5    | 135      | 1    |
| 5    | 112.5    | 123.75   | 135      | 0    |
| 6    | 112.5    | 118.125  | 123.75   | 1    |
| 7    | 118.125  | 120.9375 | 123.75   | 1    |
| 8    | 120.9375 | 122.3438 | 123.75   | 1    |
| 9    | 122.3438 | 123.0469 | 123.75   | 1    |
| 10   | 123.0469 | 123.3984 | 123.75   | 0    |
| 11   | 123.0469 | 123.2227 | 123.3984 | 0    |
| 12   | 123.0469 | 123.1348 | 123.2227 | 1    |
| 13   | 123.1348 | 123.1787 | 123.2227 | 0    |
| 14   | 123.1348 | 123.1567 | 123.1787 | 0    |
| 15   | 123.1348 | 123.1458 | 123.1567 | 1    |
| 16   | 123.1458 | 123.1512 | 123.1567 | 1    |
| 17   | 123.1512 | 123.154  | 123.1567 | 1    |
| 18   | 123.154  | 123.1554 | 123.1567 | 0    |
| 19   | 123.154  | 123.1547 | 123.1554 | 1    |
| 20   | 123.1547 | 123.155  | 123.1554 | 0    |

```1c
#经度转换结果
11010111100100111010

#维度转换结果
10111000011001110011
```

2、两个二进制组合，经度占偶数位，纬度占奇数位

```apache
11100 11101 10101 01001 01100 00111 11100 01101
#8个10进制数
28 29 21 9 12 7 28 13
wxp9d7we
```

3、每5位一组，进行base32编码

base32编码参照



### GeoHash应用原理介绍

GeoHash将二维的经纬度转换成字符串，比如下图展示了北京9个区域的GeoHash字符串，分别是WX4ER，WX4G2、WX4G3等等，每一个字符串代表了某一矩形区域。也就是说，这个矩形区域内所有的点（经纬度坐标）都共享相同的GeoHash字符串，这样既可以保护隐私（只表示大概区域位置而不是具体的点），又比较容易做缓存，比如左上角这个区域内的用户不断发送位置信息请求餐馆数据，由于这些用户的GeoHash字符串都是WX4ER，所以可以把WX4ER当作key，把该区域的餐馆信息当作value来进行缓存，而如果不使用GeoHash的话，由于区域内的用户传来的经纬度是各不相同的，很难做缓存。

字符串越长，表示的范围越精确。如图所示，5位的编码能表示10平方千米范围的矩形区域，而6位编码能表示更精细的区域（约0.34平方千米）

通过上面的介绍我们知道了GeoHash就是一种将经纬度转换成字符串的方法，并且使得在大部分情况下，字符串前缀匹配越多的距离越近，回到我们的案例，根据所在位置查询来查询附近餐馆时，只需要将所在位置经纬度转换成GeoHash字符串，并与各个餐馆的GeoHash字符串进行前缀匹配，匹配越多的距离越近。



### GeoHash算法的步骤

理论略过，网上一大堆，参考： Geohash ：https://en.wikipedia.org/wiki/Geohash

简单讲一下Peano空间填充曲线

如图所示，我们将二进制编码的结果填写到空间中，当将空间划分为四块时候，编码的顺序分别是左下角00，左上角01，右下脚10，右上角11，也就是类似于Z的曲线，当我们递归的将各个块分解成更小的子块时，编码的顺序是自相似的（分形），每一个子快也形成Z曲线，这种类型的曲线被称为Peano空间填充曲线。

　　这种类型的空间填充曲线的优点是将二维空间转换成一维曲线（事实上是分形维），对大部分而言，编码相似的距离也相近， 但Peano空间填充曲线最大的缺点就是突变性，有些编码相邻但距离却相差很远，比如0111与1000，编码是相邻的，但距离相差很大。



### GeoHash的缺陷及解决方法

- 边界问题

由于GeoHash是将区域划分为一个个规则矩形，并对每个矩形进行编码，就导致了geohash算法会有突变性，这样在查询附近信息时会导致距离很近的2个位置，GeoHash编码缺不一样，（因为不在同一个GeoHash区域块上），而近的GeoHash编码与我们不一致。

在当前点位于矩形的边界位置或者靠近边界位置时，与其最近的点可能处于边界另一侧的矩形内，这种情形下就无法匹配到最近的点。针对这种情况最直观的想法是把当前点所在矩形的周围八个矩形也包括进来，这样能保证输入的点集一定包括潜在的最近点。我们查询时，除了使用定位点的GeoHash编码进行匹配外，还使用周围8个区域的GeoHash编码，，再使用这8个点去取数据，最后再做merge、sort，这样可以避免这个问题。 8个点的算法：这个问题之前很困惑，怎么找效率最高，按照顺时针，8个方向：北、东北、东、东南、南、西南、西、西北，分别将当前位置的精度、维度的二进制提取出来，针对北的计算，则将维度+1，东北的则经度+1，维度+1,以此类推，最后再做组合计算，得到点的geohash。



## geohash的使用

geohash的位数是9位数的时候，误差约为4米;geohash的位数是10位数的时候，误差为0.6米

| geohash长度 | Lat位数 | Lon位数 | Lat误差     | Lon误差     | Km误差     |
| ----------- | ------- | ------- | ----------- | ----------- | ---------- |
| 1           | 2       | 3       | ±23         | ±23         | ±2500      |
| 2           | 5       | 5       | ± 2.8       | ±5.6        | ±630       |
| 3           | 7       | 8       | ± 0.70      | ± 0.7       | ±78        |
| 4           | 10      | 10      | ± 0.087     | ± 0.18      | ±20        |
| 5           | 12      | 13      | ± 0.022     | ± 0.022     | ±2.4       |
| 6           | 15      | 15      | ± 0.0027    | ± 0.0055    | ±0.61      |
| 7           | 17      | 18      | ±0.00068    | ±0.00068    | ±0.076     |
| 8           | 20      | 20      | ±0.000086   | ±0.000172   | ±0.01911   |
| 9           | 22      | 23      | ±0.000021   | ±0.000021   | ±0.00478   |
| 10          | 25      | 25      | ±0.00000268 | ±0.00000536 | ±0.0005971 |
| 11          | 27      | 28      | ±0.00000067 | ±0.00000067 | ±0.0001492 |
| 12          | 30      | 30      | ±0.00000008 | ±0.00000017 | ±0.0000186 |

假设数据库中存储了所有用户的geohash，根据经纬度获取附近的人：

1. 给定经纬度，计算geohash
2. 根据半径范围选取最小的区块，例如600m附近，可以使用6位的geohash作为最小区块
3. 由于自身可能在最小区块内的任意位置，因此需要一并获取最小区块的周围8个临近区块
4. 数据库中筛选geohash的6位前缀在这9个中的所有用户，然后计算距离，排除距离外的用户





### 经纬度距离换算

如果geohash的位数是9位数的时候，大概为附近2米 a）在纬度相等的情况下：

> 经度每隔0.00001度，距离相差约1米； 每隔0.0001度，距离相差约10米； 每隔0.001度，距离相差约100米； 每隔0.01度，距离相差约1000米； 每隔0.1度，距离相差约10000米。

b）在经度相等的情况下：

> 纬度每隔0.00001度，距离相差约1.1米； 每隔0.0001度，距离相差约11米； 每隔0.001度，距离相差约111米； 每隔0.01度，距离相差约1113米； 每隔0.1度，距离相差约11132米。





## redis的geo命令

6个命令：

- **[GEOADD](https://link.segmentfault.com/?enc=ND%2FcrEyZq4jw0k%2B6jBCA8g%3D%3D.ro99uJeQz1urmgMRlCRRuNcixVUO85pmOytQ6wnxX8JxIVnQhvToJNnAzLEhtqih)** 添加经纬度坐标到集合中
- **[GEODIST](https://link.segmentfault.com/?enc=RuPKNbfw9xW7e2PDmGK3Rg%3D%3D.Knw6b4ujfARTdIlLaXCC2ckGDkW%2BNBmFJzhID8vooC8FcD2B8Sw%2B8tnEoEVG5EJk)** 获取集合中两个成员的距离
- **[GEOHASH](https://link.segmentfault.com/?enc=FM2wLk3NA1MzID4SOUQDNg%3D%3D.0Imias4HgoZ4qwgorUoEUISX%2FS%2Fw0dQoD8X8lbkj6FcLMyPzLP0UI1jJ4oYtIhc4)** 获取成员的geohash
- **[GEOPOS](https://link.segmentfault.com/?enc=gxCSa8m8A8MXDzWC3nZV0w%3D%3D.v9mcTNNSW2HcwVERrq8gvyRH%2F3i5NmNsaDK2U0SjQ11Xr%2BdFfQ6CuSi9uzU%2BrENZ)** 获取集合中成员的经纬度坐标
- **[GEORADIUS](https://link.segmentfault.com/?enc=xsBorMBo2B%2BN%2BKhb9e9L%2FQ%3D%3D.ZKCfXs97iumpQ8gK6jcUkiD%2FXgm%2F2xSrTzFRQthzbTpCpo6Sxn55jyv6MHJ2kT2Z)** 根据经纬度获取给定半径内的成员列表
- **[GEORADIUSBYMEMBER](https://link.segmentfault.com/?enc=V0l13Nj6qZhfi2zKw0zAjQ%3D%3D.rh%2FIucyRh60US1xD0hXYm4r0XqcwYXQz3%2FiKTJqzjmG4LjNLL43bg3lSTi3pQwrL)** 根据成员获取给定半径内的成员列表

geoadd命令：

```maxima
GEOADD key longitude latitude member
```

1. 操作参数是经纬度，经度范围：-180 to 180 degrees.纬度范围：-85.05112878 to 85.05112878 degrees.
2. 实际存储的数据类型是zset，第四个参数member是zset的value，score是根据经纬度计算出geohash
3. geohash的精度：52bit的长整型，计算距离使用的公式是：Haversine
4. 实际在redis中的数据如下图，其中score是52bit的长整型
5. 由于实际存储的是geohash值，所以使用geopos获取的经纬度与实际保存值有一定误差
6. 删除使用zrem，重新geoadd会更新



附近的人查询命令：

```inform7
GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]
GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]
 
#上边两个命令有store选项，会被集群当作写命令，只会在主节点执行，可以用只读形式
GEORADIUS_RO
GEORADIUSBYMEMBER_RO
```



## redis内存占用情况测试

| 数据量 | 内存占用 |
| ------ | -------- |
| 50w    | 39.76M   |
| 100w   | 90.21M   |
| 200w   | 171.26M  |
| 500w   | 484.15M  |
| 1000w  | 907.26M  |



## 参考资料

Geohash :https://en.wikipedia.org/wiki/Geohash

Movable Type Scripts : http://www.movable-type.co.uk/scripts/geohash.html

使用 Apache Lucene 和 Solr 进行位置感知搜索  :http://www.ibm.com/developerworks/cn/java/j-spatial/

https://segmentfault.com/a/1190000038529554