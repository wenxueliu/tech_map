## 应用场景

### 优点

#### 异步任务

秒杀系统

#### 流量控制

隔离网关和后端服务

分布式流控

#### 解耦

核心和非核心的分离

微服务级别的发布订阅

连接流计算任务和数据

### 缺点

1、增加了延迟

2、增加系统复杂度

3、数据不一致风险

## 标准

JMS

AMQP

OpenMessaging

MQTT



## 核心技术

### 网络通信

Kafka: NIO
RocketMq: Netty
Pulsar: PB

### 序列化

### 一致性协议

### 分布式事务

异步编程模型

### 数据压缩

### 内存管理

文件与高性能 IO

### 高可用分布式系统

文件系统：kafka、RocketMq
分布式 KV：redis 低可靠、高性能
分布式文件系统：pulsar
数据库： 高可靠，低性能

缓存策略

#### 客户端

考虑因素：网络通信



### 应用场景

日志采集

收集监控

服务解耦

连接流计算任务

消息驱动任务

蓄洪、削峰

ETL: 异步数据库间数据同步

IoT：连接海量 IoT 设备

### 消息队列

| 维度         | RabbitMQ           | RocketMQ                     | Kafka       | pulsar | Nsq    | emp  |
| ------------ | ------------------ | ---------------------------- | ----------- | ------ | ------ | ---- |
| 消息不丢失   |                    | 可以                         | 可以        |        |        |      |
| 消息顺序     |                    | 可以                         | 可以        |        |        |      |
| 消息堆积问题 | 有                 | 没有                         | 没有        |        |        |      |
| 压缩         |                    |                              | 支持        |        |        |      |
| 集群         | 支持               | 支持                         | 支持        |        |        |      |
| 性能         | 几万到十几万       | 几十万                       | 几十万      |        |        |      |
| 二次开发     | 基于 erlang        | Java                         | Scala，Java |        | golang |      |
| 社区         | 全球               | 中文                         | 全球        |        |        |      |
| 活跃度       |                    |                              |             |        |        |      |
| 兼容性       | 最全               | 不如 kafka                   | 好          |        |        |      |
| 协议         | AMQP               |                              |             |        | MQTT   |      |
| 场景         | 通用               | 延迟敏感、稳定性高的在线业务 | 大数据      |        |        |      |
| 特点         | 支持的客户端非常多 | 低延迟                       | 高吞吐      |        |        |      |
| 团队匹配程度 | XX                 | XX                           | XX          | XX     | XX     | XX   |

### 关键模型

#### 队列模型
* 队列
* 生产者
* 消费者

#### 发布订阅模型
* 主题
* 发布者
* 订阅者

#### 消息分片
* 分区
* 队列

#### 消费
* 消费位置
* 消费分组
* 消费幂等

#### 服务质量
* At most onece
* At least once
* Exactly once

### 关键点

1、选型：当前业务需要什么样的消息队列？

#### 如何保证消息不丢失？

生产者在发布消息时异常：

a) 网络故障或其他问题导致发布失败（直接返回错误，消息根本没发出去）
b) 网络抖动导致发布超时（可能发送数据包成功，但读取响应结果超时了，不知道结果如何）

情况a还好，消息根本没发出去，那么重新发一次就好了。但是情况b没办法知道到底有没有发布成功，所以也只能再发一次。所以这两种情况，生产者都需要重新发布消息，直到成功为止（一般设定一个最大重试次数，超过最大次数依旧失败的需要报警处理）。这就会导致消费者可能会收到重复消息的问题，所以消费者需要保证在收到重复消息时，依旧能保证业务的正确性（设计幂等逻辑），一般需要根据具体业务来做，例如使用消息的唯一ID，或者版本号配合业务逻辑来处理。

2、消费者在处理消息时异常：

采用ack的方式，

成功：返回 Ok

失败，返会错误，要求 broken 重发消息

3、消息队列中间件丢失消息

多个节点+预写磁盘的方式保证消息的完整性

#### 如何处理消息重复问题？

也是消息可靠的副作用。





4、消息积压了如何处理？

5、如何做到水平扩展




### 参考

https://rocketmq.apache.org/docs/quick-start/
https://rocketmq.cloud/zh-cn/
https://kafka.apache.org/documentation/
https://www.rabbitmq.com/documentation.html/



### 思考题

RocketMQ 较 Kafka 是低延迟的？

1. send 之后，RocketMQ 立即把消息发送出去
2. send 之后，Kafka 把消息放到本地缓存里面，然后异步批量发送。